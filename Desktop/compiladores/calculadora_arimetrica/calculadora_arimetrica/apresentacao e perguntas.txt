Perguntas Básicas e Óbvias
1. O que o projeto faz?

Resposta: "Nosso projeto é a primeira parte de um compilador, o front-end. Ele faz a análise léxica e sintática de um código-fonte escrito em uma versão simplificada de C++, validando se a estrutura do código está correta de acordo com a nossa gramática."
2. Quais ferramentas vocês usaram?

Resposta: "Usamos a linguagem Python com a biblioteca PLY, que é uma implementação das ferramentas Lex e Yacc para análise léxica e sintática."
3. Qual a função do analisador léxico (lexer.py)?

Resposta: "A função dele é ler o código-fonte e quebrá-lo em 'pedaços' menores chamados tokens. Ele transforma o texto puro, como if, x, =, 10, em unidades que o parser consegue entender, como PALAVRA_CHAVE, IDENTIFICADOR, OPERADOR e CONSTANTE."
4. E qual a função do analisador sintático (parser.py)?

Resposta: "O parser recebe a sequência de tokens do lexer e verifica se ela segue as regras gramaticais da nossa linguagem. Ele é o responsável por entender a estrutura, como uma declaração de variável, um comando if ou um laço while. Se a estrutura estiver errada, ele aponta um erro sintático."
Perguntas Intermediárias (Sobre o Funcionamento)
5. Como o lexer sabe que if é uma palavra-chave e main é um identificador?

Resposta: "Nós usamos um dicionário de palavras reservadas. A regra do identificador captura qualquer sequência de letras, mas antes de retornar o token, ela verifica se essa sequência está no nosso dicionário. Se estiver, ela muda o tipo do token para PALAVRA_CHAVE; se não, ele continua sendo um IDENTIFICADOR."
6. O que é a Tabela de Símbolos (tabela_simbolos) e para que serve?

Resposta: "É um dicionário que usamos para fazer a análise semântica básica. Quando uma variável é declarada, nós a guardamos na tabela com seu tipo. Antes de usar uma variável, consultamos a tabela para garantir que ela já foi declarada, evitando erros de 'variável não declarada'."
7. O que é a precedência de operadores e como vocês trataram isso?

Resposta: "A precedência define qual operação é feita primeiro, como a multiplicação antes da adição. Nós tratamos isso no parser usando a tupla precedence, uma diretiva da biblioteca PLY que resolve ambiguidades em expressões matemáticas automaticamente."
8. Por que a ordem das funções p_... no arquivo do parser é importante?

Resposta: "Porque a biblioteca PLY define a primeira função de regra, no nosso caso a p_programa, como o ponto de partida de toda a gramática. Se outra regra viesse antes, o parser tentaria analisar o arquivo inteiro usando aquela regra menor, o que causaria um erro imediato."
Perguntas Mais Complexas (Sobre Limitações e Próximos Passos)
9. O que aconteceria se eu declarasse a mesma variável duas vezes? O compilador detecta?

Resposta: "Sim, ele detecta. Antes de adicionar uma nova variável na tabela de símbolos, nossa função add_variavel_tabela verifica se ela já existe. Se existir, ele emite um erro semântico de 'variável já declarada' e aborta a análise."
10. Como o projeto lida com escopo de variáveis (globais vs. locais)?

Resposta: "Atualmente, ele não lida com escopos diferentes. Nossa tabela de símbolos é global. Declarar uma variável com o mesmo nome em duas funções diferentes resultaria em um erro de 'variável já declarada'. Implementar escopo seria um dos próximos passos lógicos para evoluir o projeto."
11. O resultado da análise de vocês é um texto. Qual seria o próximo passo em um compilador real?

Resposta: "O próximo passo seria gerar uma estrutura de dados intermediária, como uma Árvore de Sintaxe Abstrata (AST). Essa árvore representa o código de forma organizada e seria usada nas próximas fases do compilador, como a otimização e a geração de código de máquina."
12. O que acontece se eu tentar atribuir um float a uma variável int?

Resposta: "Nosso analisador sintático atual não faz essa verificação de tipo na atribuição. Ele garante que a estrutura variavel = expressao está correta, mas a checagem de compatibilidade de tipos seria uma função mais avançada da análise semântica, que poderia ser implementada a seguir."